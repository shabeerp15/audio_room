'use strict';

var uuid = require('uuid');
var jwt = require('jsonwebtoken');
var crypto = require('crypto');

/**
 * @export
 */
const APNConfigRequestAuthTypeEnum = {
    CERTIFICATE: 'certificate',
    TOKEN: 'token'
};
/**
 * @export
 */
const AppSearchBackendEnum = {
    ELASTICSEARCH: 'elasticsearch',
    POSTGRES: 'postgres',
    DISABLED: 'disabled'
};
/**
 * @export
 */
const AsyncModerationCallbackConfigRequestModeEnum = {
    NONE: 'CALLBACK_MODE_NONE',
    REST: 'CALLBACK_MODE_REST',
    TWIRP: 'CALLBACK_MODE_TWIRP'
};
/**
 * @export
 */
const AudioSettingsDefaultDeviceEnum = {
    SPEAKER: 'speaker',
    EARPIECE: 'earpiece'
};
/**
 * @export
 */
const BlockListOptionsBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const BlockListOptionsRequestBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelConfigAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigRequestBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigWithInfoAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelConfigWithInfoAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigWithInfoBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigWithInfoRequestAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelConfigWithInfoRequestAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelConfigWithInfoRequestBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelMemberRoleEnum = {
    MEMBER: 'member',
    MODERATOR: 'moderator',
    ADMIN: 'admin',
    OWNER: 'owner'
};
/**
 * @export
 */
const ChannelMemberRequestRoleEnum = {
    MEMBER: 'member',
    MODERATOR: 'moderator',
    ADMIN: 'admin',
    OWNER: 'owner'
};
/**
 * @export
 */
const ChannelTypeConfigAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelTypeConfigAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const ChannelTypeConfigBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const CheckPushRequestPushProviderTypeEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const CheckSNSResponseStatusEnum = {
    OK: 'ok',
    ERROR: 'error'
};
/**
 * @export
 */
const CheckSQSResponseStatusEnum = {
    OK: 'ok',
    ERROR: 'error'
};
/**
 * @export
 */
const ConfigDefaultRoleEnum = {
    ATTENDEE: 'attendee',
    PUBLISHER: 'publisher',
    SUBSCRIBER: 'subscriber',
    ADMIN: 'admin'
};
/**
 * @export
 */
const ConfigRequestDefaultRoleEnum = {
    ATTENDEE: 'attendee',
    PUBLISHER: 'publisher',
    SUBSCRIBER: 'subscriber',
    ADMIN: 'admin'
};
/**
 * @export
 */
const CreateCallRequestTypeEnum = {
    AUDIO: 'audio',
    VIDEO: 'video'
};
/**
 * @export
 */
const CreateChannelTypeRequestAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const CreateChannelTypeRequestAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const CreateChannelTypeRequestBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const CreateChannelTypeResponseAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const CreateChannelTypeResponseAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const CreateChannelTypeResponseBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const CreateDeviceRequestPushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const CreateImportRequestModeEnum = {
    INSERT: 'insert',
    UPSERT: 'upsert'
};
/**
 * @export
 */
const DeleteUsersRequestConversationsEnum = {
    SOFT: 'soft',
    HARD: 'hard'
};
/**
 * @export
 */
const DeleteUsersRequestMessagesEnum = {
    SOFT: 'soft',
    PRUNING: 'pruning',
    HARD: 'hard'
};
/**
 * @export
 */
const DeleteUsersRequestUserEnum = {
    SOFT: 'soft',
    PRUNING: 'pruning',
    HARD: 'hard'
};
/**
 * @export
 */
const DevicePushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const DeviceFieldsPushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const DeviceRequestPushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const ImageSizeCropEnum = {
    TOP: 'top',
    BOTTOM: 'bottom',
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center'
};
/**
 * @export
 */
const ImageSizeResizeEnum = {
    CLIP: 'clip',
    CROP: 'crop',
    SCALE: 'scale',
    FILL: 'fill'
};
/**
 * @export
 */
const LayoutSettingsNameEnum = {
    SPOTLIGHT: 'spotlight',
    GRID: 'grid',
    SINGLE_PARTICIPANT: 'single-participant',
    MOBILE: 'mobile',
    CUSTOM: 'custom'
};
/**
 * @export
 */
const MessageTypeEnum = {
    REGULAR: 'regular',
    EPHEMERAL: 'ephemeral',
    ERROR: 'error',
    REPLY: 'reply',
    SYSTEM: 'system',
    DELETED: 'deleted'
};
/**
 * @export
 */
const MessageRequestTypeEnum = {
    REGULAR: 'regular',
    EPHEMERAL: 'ephemeral',
    ERROR: 'error',
    REPLY: 'reply',
    SYSTEM: 'system',
    DELETED: 'deleted'
};
/**
 * @export
 */
const MessageRequest1TypeEnum = {
    REGULAR: 'regular',
    EPHEMERAL: 'ephemeral',
    ERROR: 'error',
    REPLY: 'reply',
    SYSTEM: 'system',
    DELETED: 'deleted'
};
/**
 * @export
 */
const PermissionLevelEnum = {
    APP: 'app',
    CHANNEL: 'channel'
};
/**
 * @export
 */
const PolicyRequestActionEnum = {
    DENY: 'Deny',
    ALLOW: 'Allow'
};
/**
 * @export
 */
const PolicyRequest1ActionEnum = {
    DENY: 'Deny',
    ALLOW: 'Allow'
};
/**
 * @export
 */
const PushConfigRequestVersionEnum = {
    V1: 'v1',
    V2: 'v2'
};
/**
 * @export
 */
const TranscriptionSettingsModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const TranslateMessageRequestLanguageEnum = {
    AF: 'af',
    SQ: 'sq',
    AM: 'am',
    AR: 'ar',
    AZ: 'az',
    BN: 'bn',
    BS: 'bs',
    BG: 'bg',
    ZH: 'zh',
    ZH_TW: 'zh-TW',
    HR: 'hr',
    CS: 'cs',
    DA: 'da',
    FA_AF: 'fa-AF',
    NL: 'nl',
    EN: 'en',
    ET: 'et',
    FI: 'fi',
    FR: 'fr',
    FR_CA: 'fr-CA',
    KA: 'ka',
    DE: 'de',
    EL: 'el',
    HA: 'ha',
    HE: 'he',
    HI: 'hi',
    HU: 'hu',
    ID: 'id',
    IT: 'it',
    JA: 'ja',
    KO: 'ko',
    LV: 'lv',
    MS: 'ms',
    NO: 'no',
    FA: 'fa',
    PS: 'ps',
    PL: 'pl',
    PT: 'pt',
    RO: 'ro',
    RU: 'ru',
    SR: 'sr',
    SK: 'sk',
    SL: 'sl',
    SO: 'so',
    ES: 'es',
    ES_MX: 'es-MX',
    SW: 'sw',
    SV: 'sv',
    TL: 'tl',
    TA: 'ta',
    TH: 'th',
    TR: 'tr',
    UK: 'uk',
    UR: 'ur',
    VI: 'vi'
};
/**
 * @export
 */
const UpdateAppRequestEnforceUniqueUsernamesEnum = {
    NO: 'no',
    APP: 'app',
    TEAM: 'team'
};
/**
 * @export
 */
const UpdateAppRequestPermissionVersionEnum = {
    V1: 'v1',
    V2: 'v2'
};
/**
 * @export
 */
const UpdateAppRequestVideoProviderEnum = {
    AGORA: 'agora',
    HMS: 'hms'
};
/**
 * @export
 */
const UpdateChannelTypeRequestAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const UpdateChannelTypeRequestAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const UpdateChannelTypeRequestBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const UpdateChannelTypeResponseAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const UpdateChannelTypeResponseAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const UpdateChannelTypeResponseBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const VideoSettingsCameraFacingEnum = {
    FRONT: 'front',
    BACK: 'back',
    EXTERNAL: 'external'
};

/**
 * @export
 */
const VideoAudioSettingsRequestDefaultDeviceEnum = {
    SPEAKER: 'speaker',
    EARPIECE: 'earpiece'
};
/**
 * @export
 */
const VideoAudioSettingsResponseDefaultDeviceEnum = {
    SPEAKER: 'speaker',
    EARPIECE: 'earpiece'
};
/**
 * @export
 */
const VideoCreateDeviceRequestPushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const VideoDevicePushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const VideoLayoutSettingsRequestNameEnum = {
    SPOTLIGHT: 'spotlight',
    GRID: 'grid',
    SINGLE_PARTICIPANT: 'single-participant',
    MOBILE: 'mobile',
    CUSTOM: 'custom'
};
/**
 * @export
 */
const VideoLayoutSettingsResponseNameEnum = {
    SPOTLIGHT: 'spotlight',
    GRID: 'grid',
    SINGLE_PARTICIPANT: 'single-participant',
    MOBILE: 'mobile',
    CUSTOM: 'custom'
};
/**
 * @export
 */
const VideoNoiseCancellationSettingsModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * All possibility of string to use
 * @export
 */
const VideoOwnCapability = {
    BLOCK_USERS: 'block-users',
    CHANGE_MAX_DURATION: 'change-max-duration',
    CREATE_CALL: 'create-call',
    CREATE_REACTION: 'create-reaction',
    ENABLE_NOISE_CANCELLATION: 'enable-noise-cancellation',
    END_CALL: 'end-call',
    JOIN_BACKSTAGE: 'join-backstage',
    JOIN_CALL: 'join-call',
    JOIN_ENDED_CALL: 'join-ended-call',
    MUTE_USERS: 'mute-users',
    PIN_FOR_EVERYONE: 'pin-for-everyone',
    READ_CALL: 'read-call',
    REMOVE_CALL_MEMBER: 'remove-call-member',
    SCREENSHARE: 'screenshare',
    SEND_AUDIO: 'send-audio',
    SEND_VIDEO: 'send-video',
    START_BROADCAST_CALL: 'start-broadcast-call',
    START_RECORD_CALL: 'start-record-call',
    START_TRANSCRIPTION_CALL: 'start-transcription-call',
    STOP_BROADCAST_CALL: 'stop-broadcast-call',
    STOP_RECORD_CALL: 'stop-record-call',
    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',
    UPDATE_CALL: 'update-call',
    UPDATE_CALL_MEMBER: 'update-call-member',
    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',
    UPDATE_CALL_SETTINGS: 'update-call-settings'
};
/**
 * @export
 */
const VideoRecordSettingsRequestModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const VideoRecordSettingsRequestQualityEnum = {
    _360P: '360p',
    _480P: '480p',
    _720P: '720p',
    _1080P: '1080p',
    _1440P: '1440p'
};
/**
 * @export
 */
const VideoTranscriptionSettingsRequestModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const VideoTranscriptionSettingsResponseModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const VideoVideoSettingsRequestCameraFacingEnum = {
    FRONT: 'front',
    BACK: 'back',
    EXTERNAL: 'external'
};
/**
 * @export
 */
const VideoVideoSettingsResponseCameraFacingEnum = {
    FRONT: 'front',
    BACK: 'back',
    EXTERNAL: 'external'
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH$1 = "https://chat.stream-io-api.com".replace(/\/+$/, "");
let Configuration$1 = class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring$1;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
};
const DefaultConfig$1 = new Configuration$1();
/**
 * This is the base class for all generated API classes.
 */
let BaseAPI$1 = class BaseAPI {
    constructor(configuration = DefaultConfig$1) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            }
            catch (e) {
                for (const middleware of this.middleware) {
                    if (middleware.onError) {
                        response = (yield middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined,
                        })) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');
                    }
                    else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    request(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = yield this.createFetchParams(context, initOverrides);
            const response = yield this.fetchApi(url, init);
            if (response && (response.status >= 200 && response.status < 300)) {
                return response;
            }
            throw new ResponseError$1(response, 'Response returned an error code');
        });
    }
    createFetchParams(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.configuration.basePath + context.path;
            if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                // only add the querystring to the URL if there are query parameters.
                // this is done to avoid urls ending with a "?" character which buggy webservers
                // do not handle correctly sometimes.
                url += '?' + this.configuration.queryParamsStringify(context.query);
            }
            const headers = Object.assign({}, this.configuration.headers, context.headers);
            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
            const initOverrideFn = typeof initOverrides === "function"
                ? initOverrides
                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });
            const initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials,
            };
            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({
                init: initParams,
                context,
            })));
            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData$1(overriddenInit.body) ||
                    overriddenInit.body instanceof URLSearchParams ||
                    isBlob$1(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body) });
            return { url, init };
        });
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};
BaseAPI$1.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
function isBlob$1(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData$1(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
let ResponseError$1 = class ResponseError extends Error {
    constructor(response, msg) {
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
};
let FetchError$1 = class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
};
let RequiredError$1 = class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
};
const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
function querystring$1(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey$1(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey$1(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey$1(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring$1(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
let JSONApiResponse$1 = class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
};
class VoidApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class ChannelTypesApi extends BaseAPI$1 {
    /**
     * Creates new channel type
     * Create channel type
     */
    createChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {
                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createChannelTypeRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates new channel type
     * Create channel type
     */
    createChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes channel type
     * Delete channel type
     */
    deleteChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes channel type
     * Delete channel type
     */
    deleteChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets channel type
     * Get channel type
     */
    getChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets channel type
     * Get channel type
     */
    getChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available channel types
     * List channel types
     */
    listChannelTypesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available channel types
     * List channel types
     */
    listChannelTypes(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listChannelTypesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates channel type
     * Update channel type
     */
    updateChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');
            }
            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {
                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelTypeRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates channel type
     * Update channel type
     */
    updateChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class ChannelsApi extends BaseAPI$1 {
    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Delete channel
     */
    deleteChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteChannel.');
            }
            const queryParameters = {};
            if (requestParameters.hardDelete !== undefined) {
                queryParameters['hard_delete'] = requestParameters.hardDelete;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Delete channel
     */
    deleteChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Deletes channels asynchronously
     */
    deleteChannelsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {
                throw new RequiredError$1('deleteChannelsRequest', 'Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/delete`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deleteChannelsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Deletes channels asynchronously
     */
    deleteChannels(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Exports channel data to JSON file
     * Export channels
     */
    exportChannelsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {
                throw new RequiredError$1('exportChannelsRequest', 'Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/export_channels`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.exportChannelsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Exports channel data to JSON file
     * Export channels
     */
    exportChannels(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exportChannelsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Export channels status
     */
    getExportChannelsStatusRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/export_channels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     *
     * Export channels status
     */
    getExportChannelsStatus(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getExportChannelsStatusRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start
     * Get or create channel
     */
    getOrCreateChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');
            }
            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {
                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/query`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.channelGetOrCreateRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start
     * Get or create channel
     */
    getOrCreateChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOrCreateChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel
     * Hide channel
     */
    hideChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling hideChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling hideChannel.');
            }
            if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {
                throw new RequiredError$1('hideChannelRequest', 'Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/hide`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.hideChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel
     * Hide channel
     */
    hideChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.hideChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    markChannelsReadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {
                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/read`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markChannelsReadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    markChannelsRead(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    markReadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');
            }
            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {
                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/read`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markReadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    markRead(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markReadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    markUnreadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');
            }
            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {
                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/unread`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markUnreadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    markUnread(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markUnreadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel
     * Mute channel
     */
    muteChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {
                throw new RequiredError$1('muteChannelRequest', 'Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/mute/channel`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.muteChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel
     * Mute channel
     */
    muteChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.muteChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Query channels with filter query  Required permissions: - ReadChannel
     * Query channels
     */
    queryChannelsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {
                throw new RequiredError$1('queryChannelsRequest', 'Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryChannelsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Query channels with filter query  Required permissions: - ReadChannel
     * Query channels
     */
    queryChannels(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryChannelsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter channel members  Required permissions: - ReadChannel
     * Query members
     */
    queryMembersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/members`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter channel members  Required permissions: - ReadChannel
     * Query members
     */
    queryMembers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryMembersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    searchRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/search`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    search(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Shows previously hidden channel  Sends events: - channel.visible
     * Show channel
     */
    showChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling showChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling showChannel.');
            }
            if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {
                throw new RequiredError$1('showChannelRequest', 'Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/show`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.showChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Shows previously hidden channel  Sends events: - channel.visible
     * Show channel
     */
    showChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.showChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel
     * Truncate channel
     */
    truncateChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling truncateChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling truncateChannel.');
            }
            if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {
                throw new RequiredError$1('truncateChannelRequest', 'Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/truncate`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.truncateChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel
     * Truncate channel
     */
    truncateChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.truncateChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel
     * Unmute channel
     */
    unmuteChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {
                throw new RequiredError$1('unmuteChannelRequest', 'Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/unmute/channel`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.unmuteChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel
     * Unmute channel
     */
    unmuteChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unmuteChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * UnreadCount counts
     * UnreadCount counts
     */
    unreadCountsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/unread`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * UnreadCount counts
     * UnreadCount counts
     */
    unreadCounts(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unreadCountsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers
     * Update channel
     */
    updateChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannel.');
            }
            if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {
                throw new RequiredError$1('updateChannelRequest', 'Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers
     * Update channel
     */
    updateChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen
     * Partially update channel
     */
    updateChannelPartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');
            }
            if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {
                throw new RequiredError$1('updateChannelPartialRequest', 'Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelPartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen
     * Partially update channel
     */
    updateChannelPartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelPartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class CustomCommandsApi extends BaseAPI$1 {
    /**
     * Creates custom chat command
     * Create command
     */
    createCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {
                throw new RequiredError$1('createCommandRequest', 'Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createCommandRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates custom chat command
     * Create command
     */
    createCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes custom chat command
     * Delete command
     */
    deleteCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes custom chat command
     * Delete command
     */
    deleteCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns custom command by its name
     * Get command
     */
    getCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns custom command by its name
     * Get command
     */
    getCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all custom commands
     * List commands
     */
    listCommandsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns all custom commands
     * List commands
     */
    listCommands(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listCommandsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates custom chat command
     * Update command
     */
    updateCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateCommand.');
            }
            if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {
                throw new RequiredError$1('updateCommandRequest', 'Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateCommandRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates custom chat command
     * Update command
     */
    updateCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class DevicesApi extends BaseAPI$1 {
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {
                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createDeviceRequest,
            }, initOverrides);
            return new VoidApiResponse(response);
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createDeviceRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.id !== undefined) {
                queryParameters['id'] = requestParameters.id;
            }
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDevice(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevicesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevices(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listDevicesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class EventsApi extends BaseAPI$1 {
    /**
     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent
     * Send event
     */
    sendEventRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');
            }
            if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {
                throw new RequiredError$1('sendEventRequest', 'Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendEventRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent
     * Send event
     */
    sendEvent(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendEventRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends a custom event to a user  Sends events: - custom
     * Send user event
     */
    sendUserCustomEventRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');
            }
            if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {
                throw new RequiredError$1('sendUserCustomEventRequest', 'Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/event`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendUserCustomEventRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends a custom event to a user  Sends events: - custom
     * Send user event
     */
    sendUserCustomEvent(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendUserCustomEventRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class MessagesApi extends BaseAPI$1 {
    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment
     * Delete file
     */
    deleteFileRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteFile.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteFile.');
            }
            const queryParameters = {};
            if (requestParameters.url !== undefined) {
                queryParameters['url'] = requestParameters.url;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment
     * Delete file
     */
    deleteFile(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteFileRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment
     * Delete image
     */
    deleteImageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteImage.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteImage.');
            }
            const queryParameters = {};
            if (requestParameters.url !== undefined) {
                queryParameters['url'] = requestParameters.url;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment
     * Delete image
     */
    deleteImage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteImageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage
     * Delete message
     */
    deleteMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteMessage.');
            }
            const queryParameters = {};
            if (requestParameters.hard !== undefined) {
                queryParameters['hard'] = requestParameters.hard;
            }
            if (requestParameters.deletedBy !== undefined) {
                queryParameters['deleted_by'] = requestParameters.deletedBy;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage
     * Delete message
     */
    deleteMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction
     * Delete reaction
     */
    deleteReactionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteReaction.');
            }
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteReaction.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reaction/{type}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction
     * Delete reaction
     */
    deleteReaction(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteReactionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    flagRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/flag`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.flagRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    flag(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.flagRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel
     * Get many messages
     */
    getManyMessagesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getManyMessages.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getManyMessages.');
            }
            const queryParameters = {};
            if (requestParameters.ids) {
                queryParameters['ids'] = requestParameters.ids;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/messages`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel
     * Get many messages
     */
    getManyMessages(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getManyMessagesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns message by ID  Required permissions: - ReadChannel
     * Get message
     */
    getMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns message by ID  Required permissions: - ReadChannel
     * Get message
     */
    getMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Get an OpenGraph attachment for a link
     * Get OG
     */
    getOGRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.url !== undefined) {
                queryParameters['url'] = requestParameters.url;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/og`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Get an OpenGraph attachment for a link
     * Get OG
     */
    getOG(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOGRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel
     * Get reactions
     */
    getReactionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getReactions.');
            }
            const queryParameters = {};
            if (requestParameters.limit !== undefined) {
                queryParameters['limit'] = requestParameters.limit;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel
     * Get reactions
     */
    getReactions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getReactionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel
     * Get replies
     */
    getRepliesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.parentId === null || requestParameters.parentId === undefined) {
                throw new RequiredError$1('parentId', 'Required parameter requestParameters.parentId was null or undefined when calling getReplies.');
            }
            const queryParameters = {};
            if (requestParameters.idGte !== undefined) {
                queryParameters['id_gte'] = requestParameters.idGte;
            }
            if (requestParameters.idGt !== undefined) {
                queryParameters['id_gt'] = requestParameters.idGt;
            }
            if (requestParameters.idLte !== undefined) {
                queryParameters['id_lte'] = requestParameters.idLte;
            }
            if (requestParameters.idLt !== undefined) {
                queryParameters['id_lt'] = requestParameters.idLt;
            }
            if (requestParameters.createdAtAfterOrEqual !== undefined) {
                queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;
            }
            if (requestParameters.createdAtAfter !== undefined) {
                queryParameters['created_at_after'] = requestParameters.createdAtAfter;
            }
            if (requestParameters.createdAtBeforeOrEqual !== undefined) {
                queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;
            }
            if (requestParameters.createdAtBefore !== undefined) {
                queryParameters['created_at_before'] = requestParameters.createdAtBefore;
            }
            if (requestParameters.idAround !== undefined) {
                queryParameters['id_around'] = requestParameters.idAround;
            }
            if (requestParameters.createdAtAround !== undefined) {
                queryParameters['created_at_around'] = requestParameters.createdAtAround;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{parent_id}/replies`.replace(`{${"parent_id"}}`, encodeURIComponent(String(requestParameters.parentId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel
     * Get replies
     */
    getReplies(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getRepliesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    markChannelsReadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {
                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/read`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markChannelsReadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    markChannelsRead(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    markReadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');
            }
            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {
                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/read`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markReadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    markRead(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markReadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    markUnreadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');
            }
            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {
                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/unread`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markUnreadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    markUnread(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markUnreadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags
     * Query Message Flags
     */
    queryMessageFlagsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/flags/message`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags
     * Query Message Flags
     */
    queryMessageFlags(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryMessageFlagsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction
     * Run message command action
     */
    runMessageActionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling runMessageAction.');
            }
            if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {
                throw new RequiredError$1('messageActionRequest', 'Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/action`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.messageActionRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction
     * Run message command action
     */
    runMessageAction(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.runMessageActionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    searchRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/search`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    search(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel
     * Send new message
     */
    sendMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendMessage.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendMessage.');
            }
            if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {
                throw new RequiredError$1('sendMessageRequest', 'Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/message`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel
     * Send new message
     */
    sendMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel
     * Send reaction
     */
    sendReactionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendReaction.');
            }
            if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {
                throw new RequiredError$1('sendReactionRequest', 'Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reaction`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendReactionRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel
     * Send reaction
     */
    sendReaction(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendReactionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel
     * Translate message
     */
    translateMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling translateMessage.');
            }
            if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {
                throw new RequiredError$1('translateMessageRequest', 'Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/translate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.translateMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel
     * Translate message
     */
    translateMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.translateMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser
     * Unflag
     */
    unflagRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/unflag`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.flagRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser
     * Unflag
     */
    unflag(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unflagRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Update message
     */
    updateMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessage.');
            }
            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {
                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Update message
     */
    updateMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Partially message update
     */
    updateMessagePartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');
            }
            if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {
                throw new RequiredError$1('updateMessagePartialRequest', 'Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateMessagePartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Partially message update
     */
    updateMessagePartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateMessagePartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Uploads file  Required permissions: - UploadAttachment
     * Upload file
     */
    uploadFileRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadFile.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadFile.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const consumes = [
                { contentType: 'multipart/form-data' },
            ];
            // @ts-ignore: canConsumeForm may be unused
            canConsumeForm(consumes);
            let formParams;
            {
                formParams = new URLSearchParams();
            }
            if (requestParameters.file !== undefined) {
                formParams.append('file', requestParameters.file);
            }
            if (requestParameters.user !== undefined) {
                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Uploads file  Required permissions: - UploadAttachment
     * Upload file
     */
    uploadFile(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.uploadFileRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Uploads image  Required permissions: - UploadAttachment
     * Upload image
     */
    uploadImageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadImage.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadImage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const consumes = [
                { contentType: 'multipart/form-data' },
            ];
            // @ts-ignore: canConsumeForm may be unused
            canConsumeForm(consumes);
            let formParams;
            {
                formParams = new URLSearchParams();
            }
            if (requestParameters.file !== undefined) {
                formParams.append('file', requestParameters.file);
            }
            if (requestParameters.uploadSizes) {
                formParams.append('upload_sizes', requestParameters.uploadSizes.join(COLLECTION_FORMATS["csv"]));
            }
            if (requestParameters.user !== undefined) {
                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Uploads image  Required permissions: - UploadAttachment
     * Upload image
     */
    uploadImage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.uploadImageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class PermissionsV2Api extends BaseAPI$1 {
    /**
     * Creates custom role
     * Create role
     */
    createRoleRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {
                throw new RequiredError$1('createRoleRequest', 'Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/roles`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createRoleRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates custom role
     * Create role
     */
    createRole(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createRoleRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes custom role
     * Delete role
     */
    deleteRoleRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteRole.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/roles/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes custom role
     * Delete role
     */
    deleteRole(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteRoleRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets custom permission
     * Get permission
     */
    getPermissionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getPermission.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/permissions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets custom permission
     * Get permission
     */
    getPermission(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPermissionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available permissions
     * List permissions
     */
    listPermissionsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/permissions`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available permissions
     * List permissions
     */
    listPermissions(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listPermissionsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available roles
     * List roles
     */
    listRolesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/roles`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available roles
     * List roles
     */
    listRoles(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listRolesRaw(initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class PushApi extends BaseAPI$1 {
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {
                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createDeviceRequest,
            }, initOverrides);
            return new VoidApiResponse(response);
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createDeviceRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint
     * Delete a push provider
     */
    deletePushProviderRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');
            }
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers/{type}/{name}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint
     * Delete a push provider
     */
    deletePushProvider(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * List details of all push providers.
     * List push providers
     */
    listPushProvidersRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * List details of all push providers.
     * List push providers
     */
    listPushProviders(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listPushProvidersRaw(initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class ServerSideApi extends BaseAPI$1 {
    /**
     * Upsert a push provider for v2 with multi bundle/package support
     * Upsert a push provider
     */
    upsertPushProviderRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {
                throw new RequiredError$1('upsertPushProviderRequest', 'Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.upsertPushProviderRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Upsert a push provider for v2 with multi bundle/package support
     * Upsert a push provider
     */
    upsertPushProvider(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.upsertPushProviderRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class SettingsApi extends BaseAPI$1 {
    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings
     * Check push
     */
    checkPushRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {
                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_push`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkPushRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings
     * Check push
     */
    checkPush(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkPushRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Validates Amazon SNS configuration
     * Check SNS
     */
    checkSNSRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {
                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_sns`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkSNSRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Validates Amazon SNS configuration
     * Check SNS
     */
    checkSNS(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkSNSRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Validates Amazon SQS credentials
     * Check SQS
     */
    checkSQSRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {
                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_sqs`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkSQSRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Validates Amazon SQS credentials
     * Check SQS
     */
    checkSQS(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkSQSRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type
     * Create block list
     */
    createBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {
                throw new RequiredError$1('createBlockListRequest', 'Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createBlockListRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type
     * Create block list
     */
    createBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates new channel type
     * Create channel type
     */
    createChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {
                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createChannelTypeRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates new channel type
     * Create channel type
     */
    createChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes previously created application blocklist
     * Delete block list
     */
    deleteBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes previously created application blocklist
     * Delete block list
     */
    deleteBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes channel type
     * Delete channel type
     */
    deleteChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes channel type
     * Delete channel type
     */
    deleteChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint
     * Delete a push provider
     */
    deletePushProviderRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');
            }
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers/{type}/{name}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint
     * Delete a push provider
     */
    deletePushProvider(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This method returns the application settings
     * Get App Settings
     */
    getAppRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/app`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This method returns the application settings
     * Get App Settings
     */
    getApp(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAppRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns block list by given name
     * Get block list
     */
    getBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns block list by given name
     * Get block list
     */
    getBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets channel type
     * Get channel type
     */
    getChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets channel type
     * Get channel type
     */
    getChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Get rate limits usage and quotas
     * Get rate limits
     */
    getRateLimitsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.serverSide !== undefined) {
                queryParameters['server_side'] = requestParameters.serverSide;
            }
            if (requestParameters.android !== undefined) {
                queryParameters['android'] = requestParameters.android;
            }
            if (requestParameters.ios !== undefined) {
                queryParameters['ios'] = requestParameters.ios;
            }
            if (requestParameters.web !== undefined) {
                queryParameters['web'] = requestParameters.web;
            }
            if (requestParameters.endpoints !== undefined) {
                queryParameters['endpoints'] = requestParameters.endpoints;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/rate_limits`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Get rate limits usage and quotas
     * Get rate limits
     */
    getRateLimits(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getRateLimitsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all available block lists
     * List block lists
     */
    listBlockListsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns all available block lists
     * List block lists
     */
    listBlockLists(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listBlockListsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available channel types
     * List channel types
     */
    listChannelTypesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available channel types
     * List channel types
     */
    listChannelTypes(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listChannelTypesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * List details of all push providers.
     * List push providers
     */
    listPushProvidersRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * List details of all push providers.
     * List push providers
     */
    listPushProviders(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listPushProvidersRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * This method updates one or more application settings
     * Update App Settings
     */
    updateAppRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {
                throw new RequiredError$1('updateAppRequest', 'Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/app`,
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateAppRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This method updates one or more application settings
     * Update App Settings
     */
    updateApp(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateAppRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates contents of the block list
     * Update block list
     */
    updateBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateBlockList.');
            }
            if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {
                throw new RequiredError$1('updateBlockListRequest', 'Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateBlockListRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates contents of the block list
     * Update block list
     */
    updateBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates channel type
     * Update channel type
     */
    updateChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');
            }
            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {
                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelTypeRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates channel type
     * Update channel type
     */
    updateChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class TasksApi extends BaseAPI$1 {
    /**
     * Gets status of a task
     * Get status of a task
     */
    getTaskRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getTask.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets status of a task
     * Get status of a task
     */
    getTask(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getTaskRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class TestingApi extends BaseAPI$1 {
    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings
     * Check push
     */
    checkPushRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {
                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_push`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkPushRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings
     * Check push
     */
    checkPush(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkPushRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Validates Amazon SNS configuration
     * Check SNS
     */
    checkSNSRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {
                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_sns`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkSNSRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Validates Amazon SNS configuration
     * Check SNS
     */
    checkSNS(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkSNSRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Validates Amazon SQS credentials
     * Check SQS
     */
    checkSQSRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {
                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_sqs`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkSQSRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Validates Amazon SQS credentials
     * Check SQS
     */
    checkSQS(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkSQSRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream Chat API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v92.7.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class UsersApi extends BaseAPI$1 {
    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser
     * Ban user
     */
    banRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {
                throw new RequiredError$1('banRequest', 'Required parameter requestParameters.banRequest was null or undefined when calling ban.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/ban`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.banRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser
     * Ban user
     */
    ban(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.banRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Establishes WebSocket connection for user  Sends events: - user.updated
     * Connect (WebSocket)
     */
    connectRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.json !== undefined) {
                queryParameters['json'] = requestParameters.json;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/connect`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new VoidApiResponse(response);
        });
    }
    /**
     * Establishes WebSocket connection for user  Sends events: - user.updated
     * Connect (WebSocket)
     */
    connect(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connectRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Creates guest user
     * Create guest
     */
    createGuestRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.guestRequest === null || requestParameters.guestRequest === undefined) {
                throw new RequiredError$1('guestRequest', 'Required parameter requestParameters.guestRequest was null or undefined when calling createGuest.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/guest`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.guestRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates guest user
     * Create guest
     */
    createGuest(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createGuestRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated
     * Deactivate user
     */
    deactivateUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');
            }
            if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {
                throw new RequiredError$1('deactivateUserRequest', 'Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/deactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deactivateUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated
     * Deactivate user
     */
    deactivateUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deactivateUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deactivate users in batches  Sends events: - user.deactivated
     * Deactivate users
     */
    deactivateUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {
                throw new RequiredError$1('deactivateUsersRequest', 'Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/deactivate`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deactivateUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deactivate users in batches  Sends events: - user.deactivated
     * Deactivate users
     */
    deactivateUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deactivateUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \'Delete Users\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted
     * Delete user
     */
    deleteUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
            }
            const queryParameters = {};
            if (requestParameters.markMessagesDeleted !== undefined) {
                queryParameters['mark_messages_deleted'] = requestParameters.markMessagesDeleted;
            }
            if (requestParameters.hardDelete !== undefined) {
                queryParameters['hard_delete'] = requestParameters.hardDelete;
            }
            if (requestParameters.deleteConversationChannels !== undefined) {
                queryParameters['delete_conversation_channels'] = requestParameters.deleteConversationChannels;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \'Delete Users\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted
     * Delete user
     */
    deleteUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted
     * Delete Users
     */
    deleteUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {
                throw new RequiredError$1('deleteUsersRequest', 'Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/delete`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deleteUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted
     * Delete Users
     */
    deleteUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions
     * Export user
     */
    exportUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling exportUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/export`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions
     * Export user
     */
    exportUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exportUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Exports user profile, reactions and messages for list of given users
     * Export users
     */
    exportUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {
                throw new RequiredError$1('exportUsersRequest', 'Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/export/users`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.exportUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Exports user profile, reactions and messages for list of given users
     * Export users
     */
    exportUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exportUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    flagRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/flag`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.flagRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    flag(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.flagRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * WebSocket fallback transport endpoint  Sends events: - user.updated
     * Long Poll (Transport)
     */
    longPollRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.json !== undefined) {
                queryParameters['json'] = requestParameters.json;
            }
            if (requestParameters.connectionId !== undefined) {
                queryParameters['connection_id'] = requestParameters.connectionId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/longpoll`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new VoidApiResponse(response);
        });
    }
    /**
     * WebSocket fallback transport endpoint  Sends events: - user.updated
     * Long Poll (Transport)
     */
    longPoll(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.longPollRaw(requestParameters, initOverrides);
        });
    }
    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser
     * Mute user
     */
    muteUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {
                throw new RequiredError$1('muteUserRequest', 'Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/mute`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.muteUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser
     * Mute user
     */
    muteUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.muteUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel
     * Query Banned Users
     */
    queryBannedUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/query_banned_users`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel
     * Query Banned Users
     */
    queryBannedUsers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryBannedUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter users  Required permissions: - SearchUser
     * Query users
     */
    queryUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter users  Required permissions: - SearchUser
     * Query users
     */
    queryUsers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated
     * Reactivate user
     */
    reactivateUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');
            }
            if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {
                throw new RequiredError$1('reactivateUserRequest', 'Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/reactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.reactivateUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated
     * Reactivate user
     */
    reactivateUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.reactivateUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Reactivate users in batches  Sends events: - user.reactivated
     * Reactivate users
     */
    reactivateUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {
                throw new RequiredError$1('reactivateUsersRequest', 'Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/reactivate`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.reactivateUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Reactivate users in batches  Sends events: - user.reactivated
     * Reactivate users
     */
    reactivateUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.reactivateUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Restore soft deleted users
     * Restore users
     */
    restoreUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {
                throw new RequiredError$1('restoreUsersRequest', 'Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/restore`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.restoreUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Restore soft deleted users
     * Restore users
     */
    restoreUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.restoreUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser
     * Unban user
     */
    unbanRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.targetUserId !== undefined) {
                queryParameters['target_user_id'] = requestParameters.targetUserId;
            }
            if (requestParameters.type !== undefined) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.id !== undefined) {
                queryParameters['id'] = requestParameters.id;
            }
            if (requestParameters.createdBy !== undefined) {
                queryParameters['created_by'] = requestParameters.createdBy;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/ban`,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser
     * Unban user
     */
    unban(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unbanRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser
     * Unflag
     */
    unflagRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/unflag`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.flagRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser
     * Unflag
     */
    unflag(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unflagRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser
     * Unmute user
     */
    unmuteUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {
                throw new RequiredError$1('unmuteUserRequest', 'Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/unmute`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.unmuteUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser
     * Unmute user
     */
    unmuteUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unmuteUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Update or create users in bulk  Sends events: - user.updated
     * Upsert users
     */
    updateUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {
                throw new RequiredError$1('updateUsersRequest', 'Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Update or create users in bulk  Sends events: - user.updated
     * Upsert users
     */
    updateUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated
     * Partially update user
     */
    updateUsersPartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updateUserPartialRequest === null || requestParameters.updateUserPartialRequest === undefined) {
                throw new RequiredError$1('updateUserPartialRequest', 'Required parameter requestParameters.updateUserPartialRequest was null or undefined when calling updateUsersPartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users`,
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateUserPartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated
     * Partially update user
     */
    updateUsersPartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateUsersPartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

class StreamChannel {
    constructor(streamClient, type, id) {
        this.streamClient = streamClient;
        this.type = type;
        this.id = id;
        this.delete = (request) => {
            return this.channelsApi.deleteChannel(Object.assign(Object.assign({}, this.baseRequest), (request !== null && request !== void 0 ? request : {})));
        };
        this.update = (updateChannelRequest) => {
            return this.channelsApi.updateChannel(Object.assign(Object.assign({}, this.baseRequest), { updateChannelRequest }));
        };
        this.updatePartial = (updateChannelPartialRequest) => {
            return this.channelsApi.updateChannelPartial(Object.assign(Object.assign({}, this.baseRequest), { updateChannelPartialRequest }));
        };
        this.getOrCreate = (channelGetOrCreateRequest) => __awaiter(this, void 0, void 0, function* () {
            if (this.id) {
                return yield this.channelsApi.getOrCreateChannel(Object.assign(Object.assign({}, this.baseRequest), { channelGetOrCreateRequest: channelGetOrCreateRequest !== null && channelGetOrCreateRequest !== void 0 ? channelGetOrCreateRequest : {} }));
            }
            else {
                throw new Error(`This operation isn't yet implemented`);
                // if (!channelGetOrCreateRequest?.data?.members) {
                //   throw new Error('You need to provide members to create a channel without ID');
                // }
                // const response = await this.channelsApi.getOrCreateChannelType1({type: this.type, channelGetOrCreateRequest});
                // this.id = response.channel?.id;
                // return response;
            }
        });
        this.markRead = (markReadRequest) => {
            return this.channelsApi.markRead(Object.assign(Object.assign({}, this.baseRequest), { markReadRequest }));
        };
        this.markUnread = (markUnreadRequest) => {
            return this.channelsApi.markUnread(Object.assign(Object.assign({}, this.baseRequest), { markUnreadRequest }));
        };
        this.show = (showChannelRequest) => {
            return this.channelsApi.showChannel(Object.assign(Object.assign({}, this.baseRequest), { showChannelRequest }));
        };
        this.hide = (hideChannelRequest) => {
            return this.channelsApi.hideChannel(Object.assign(Object.assign({}, this.baseRequest), { hideChannelRequest }));
        };
        this.truncate = (truncateChannelRequest) => {
            return this.channelsApi.truncateChannel(Object.assign(Object.assign({}, this.baseRequest), { truncateChannelRequest }));
        };
        this.queryMembers = (request) => {
            return this.channelsApi.queryMembers({
                payload: Object.assign(Object.assign({}, this.baseRequest), request),
            });
        };
        this.mute = (muteChannelRequest) => {
            return this.channelsApi.muteChannel({
                muteChannelRequest: Object.assign(Object.assign({}, muteChannelRequest), { channel_cids: [this.cid] }),
            });
        };
        this.unmute = (unmuteChannelRequest) => {
            return this.channelsApi.unmuteChannel({
                unmuteChannelRequest: Object.assign(Object.assign({}, unmuteChannelRequest), { channel_cid: this.cid, channel_cids: [] }),
            });
        };
        // TODO: there is probably an issue with the generated code here
        // uploadFile = (options: Omit<OmitTypeId<UploadFileRequest>, 'file'>, file: Buffer) => {
        //   return this.messagesApi.uploadFile({...options, ...this.baseRequest, file: file as any as string});
        // }
        // deleteFile = (request: OmitTypeId<DeleteFileRequest>) => {
        //   return this.messagesApi.deleteFile({...request, ...this.baseRequest});
        // }
        // uploadImage = (request: OmitTypeId<UploadImageRequest>) => {
        //   return this.messagesApi.uploadImage({...request, ...this.baseRequest});
        // }
        // deleteImage = (request: OmitTypeId<DeleteImageRequest>) => {
        //   return this.messagesApi.deleteImage({...request, ...this.baseRequest});
        // }
        this.sendMessage = (sendMessageRequest) => {
            return this.messagesApi.sendMessage(Object.assign(Object.assign({}, this.baseRequest), { sendMessageRequest }));
        };
        this.deleteMessage = (request) => {
            return this.messagesApi.deleteMessage(request);
        };
        this.updateMessage = (id, updateMessageRequest) => {
            return this.messagesApi.updateMessage({ id, updateMessageRequest });
        };
        this.updateMessagePartial = (id, updateMessagePartialRequest) => {
            return this.messagesApi.updateMessagePartial({
                id,
                updateMessagePartialRequest,
            });
        };
        this.getMessage = (request) => {
            return this.messagesApi.getMessage(request);
        };
        this.getManyMessages = (request) => {
            return this.messagesApi.getManyMessages(Object.assign(Object.assign({}, request), this.baseRequest));
        };
        this.translateMessage = (id, translateMessageRequest) => {
            return this.messagesApi.translateMessage({ id, translateMessageRequest });
        };
        this.getMessagesAround = (request) => {
            return this.messagesApi.getReplies(request);
        };
        this.getOpenGraphData = (request) => {
            return this.messagesApi.getOG(request);
        };
        this.sendMessageReaction = (messageId, sendReactionRequest) => {
            return this.messagesApi.sendReaction({
                id: messageId,
                sendReactionRequest,
            });
        };
        this.deleteMessageReaction = (messageId, request) => {
            return this.messagesApi.deleteReaction(Object.assign(Object.assign({}, request), { id: messageId }));
        };
        this.getMessageReactions = (messageId, request) => {
            return this.messagesApi.getReactions(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), { id: messageId }));
        };
        this.sendCustomEvent = (event) => {
            return this.eventsApi.sendEvent(Object.assign(Object.assign({}, this.baseRequest), { sendEventRequest: { event } }));
        };
        const configuration = this.streamClient.getConfiguration();
        /** @ts-expect-error */
        this.channelsApi = new ChannelsApi(configuration);
        /** @ts-expect-error */
        this.messagesApi = new MessagesApi(configuration);
        /** @ts-expect-error */
        this.eventsApi = new EventsApi(configuration);
    }
    get cid() {
        return `${this.baseRequest.type}:${this.baseRequest.id}`;
    }
    get baseRequest() {
        if (!this.id) {
            throw new Error('You need to initialize the channel with `getOrCreate`');
        }
        return {
            id: this.id,
            type: this.type,
        };
    }
}

class StreamChatClient {
    constructor(streamClient) {
        this.streamClient = streamClient;
        this.channel = (type, id) => {
            return new StreamChannel(this.streamClient, type, id);
        };
        this.createBlockList = (createBlockListRequest) => {
            return this.settingsApi.createBlockList({ createBlockListRequest });
        };
        this.listBlockLists = () => {
            return this.settingsApi.listBlockLists();
        };
        this.getBlockList = (request) => {
            return this.settingsApi.getBlockList(request);
        };
        this.updateBlockList = (name, updateBlockListRequest) => {
            return this.settingsApi.updateBlockList({ name, updateBlockListRequest });
        };
        this.deleteBlockList = (request) => {
            return this.settingsApi.deleteBlockList(request);
        };
        this.createChannelType = (createChannelTypeRequest) => {
            return this.channelTypesApi.createChannelType({ createChannelTypeRequest });
        };
        this.deleteChannelType = (request) => {
            return this.channelTypesApi.deleteChannelType(request);
        };
        this.getChannelType = (request) => {
            return this.channelTypesApi.getChannelType(request);
        };
        this.listChannelTypes = () => {
            return this.channelTypesApi.listChannelTypes();
        };
        this.updateChannelType = (name, updateChannelTypeRequest) => {
            return this.channelTypesApi.updateChannelType({
                name,
                updateChannelTypeRequest,
            });
        };
        this.queryChannels = (queryChannelsRequest) => {
            return this.channelsApi.queryChannels({
                queryChannelsRequest: queryChannelsRequest !== null && queryChannelsRequest !== void 0 ? queryChannelsRequest : null,
            });
        };
        this.searchMessages = (payload) => {
            return this.channelsApi.search({ payload });
        };
        this.exportChannels = (exportChannelsRequest) => {
            return this.channelsApi.exportChannels({
                exportChannelsRequest: exportChannelsRequest !== null && exportChannelsRequest !== void 0 ? exportChannelsRequest : null,
            });
        };
        this.getExportStatus = (request) => {
            return this.channelsApi.getExportChannelsStatus(request);
        };
        this.listCommands = () => {
            return this.commandsApi.listCommands();
        };
        this.createCommand = (createCommandRequest) => {
            return this.commandsApi.createCommand({ createCommandRequest });
        };
        this.getCommand = (getCommandRequest) => {
            return this.commandsApi.getCommand(getCommandRequest);
        };
        this.updateCommand = (name, updateCommandRequest) => {
            return this.commandsApi.updateCommand({ name, updateCommandRequest });
        };
        this.deleteCommand = (request) => {
            return this.commandsApi.deleteCommand(request);
        };
        const configuration = this.streamClient.getConfiguration();
        /** @ts-expect-error */
        this.settingsApi = new SettingsApi(configuration);
        /** @ts-expect-error */
        this.channelTypesApi = new ChannelTypesApi(configuration);
        /** @ts-expect-error */
        this.channelsApi = new ChannelsApi(configuration);
        /** @ts-expect-error */
        this.commandsApi = new CustomCommandsApi(configuration);
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v116.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH = "https://stream-io-api.com".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
const DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(configuration = DefaultConfig) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            }
            catch (e) {
                for (const middleware of this.middleware) {
                    if (middleware.onError) {
                        response = (yield middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined,
                        })) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    }
                    else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    request(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = yield this.createFetchParams(context, initOverrides);
            const response = yield this.fetchApi(url, init);
            if (response && (response.status >= 200 && response.status < 300)) {
                return response;
            }
            throw new ResponseError(response, 'Response returned an error code');
        });
    }
    createFetchParams(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.configuration.basePath + context.path;
            if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                // only add the querystring to the URL if there are query parameters.
                // this is done to avoid urls ending with a "?" character which buggy webservers
                // do not handle correctly sometimes.
                url += '?' + this.configuration.queryParamsStringify(context.query);
            }
            const headers = Object.assign({}, this.configuration.headers, context.headers);
            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
            const initOverrideFn = typeof initOverrides === "function"
                ? initOverrides
                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });
            const initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials,
            };
            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({
                init: initParams,
                context,
            })));
            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||
                    overriddenInit.body instanceof URLSearchParams ||
                    isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body) });
            return { url, init };
        });
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg) {
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v116.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class ProductvideoApi extends BaseAPI {
    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser
     * Block user on a call
     */
    blockUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling blockUser.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling blockUser.');
            }
            if (requestParameters.videoBlockUserRequest === null || requestParameters.videoBlockUserRequest === undefined) {
                throw new RequiredError('videoBlockUserRequest', 'Required parameter requestParameters.videoBlockUserRequest was null or undefined when calling blockUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/block`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoBlockUserRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser
     * Block user on a call
     */
    blockUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.blockUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Check External Storage
     */
    checkExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage/{name}/check`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Check External Storage
     */
    checkExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - JoinCall
     * Collect user feedback
     */
    collectUserFeedbackRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling collectUserFeedback.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling collectUserFeedback.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling collectUserFeedback.');
            }
            if (requestParameters.videoCollectUserFeedbackRequest === null || requestParameters.videoCollectUserFeedbackRequest === undefined) {
                throw new RequiredError('videoCollectUserFeedbackRequest', 'Required parameter requestParameters.videoCollectUserFeedbackRequest was null or undefined when calling collectUserFeedback.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/feedback/{session}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCollectUserFeedbackRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - JoinCall
     * Collect user feedback
     */
    collectUserFeedback(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.collectUserFeedbackRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Create Call Type
     */
    createCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateCallTypeRequest === null || requestParameters.videoCreateCallTypeRequest === undefined) {
                throw new RequiredError('videoCreateCallTypeRequest', 'Required parameter requestParameters.videoCreateCallTypeRequest was null or undefined when calling createCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateCallTypeRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Create Call Type
     */
    createCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateDeviceRequest === null || requestParameters.videoCreateDeviceRequest === undefined) {
                throw new RequiredError('videoCreateDeviceRequest', 'Required parameter requestParameters.videoCreateDeviceRequest was null or undefined when calling createDevice.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/devices`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateDeviceRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates new external storage
     * Create external storage
     */
    createExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateExternalStorageRequest === null || requestParameters.videoCreateExternalStorageRequest === undefined) {
                throw new RequiredError('videoCreateExternalStorageRequest', 'Required parameter requestParameters.videoCreateExternalStorageRequest was null or undefined when calling createExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateExternalStorageRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Creates new external storage
     * Create external storage
     */
    createExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Create Guest
     */
    createGuestRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateGuestRequest === null || requestParameters.videoCreateGuestRequest === undefined) {
                throw new RequiredError('videoCreateGuestRequest', 'Required parameter requestParameters.videoCreateGuestRequest was null or undefined when calling createGuest.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/guest`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateGuestRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Create Guest
     */
    createGuest(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createGuestRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Delete Call Type
     */
    deleteCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Delete Call Type
     */
    deleteCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteDevice.');
            }
            const queryParameters = {};
            if (requestParameters.id !== undefined) {
                queryParameters['id'] = requestParameters.id;
            }
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/devices`,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes external storage
     * Delete external storage
     */
    deleteExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes external storage
     * Delete external storage
     */
    deleteExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes recording  Required permissions: - DeleteRecording
     * Delete recording
     */
    deleteRecordingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling deleteRecording.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteRecording.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling deleteRecording.');
            }
            if (requestParameters.filename === null || requestParameters.filename === undefined) {
                throw new RequiredError('filename', 'Required parameter requestParameters.filename was null or undefined when calling deleteRecording.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/{session}/recordings/{filename}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes recording  Required permissions: - DeleteRecording
     * Delete recording
     */
    deleteRecording(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteRecordingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes transcription  Required permissions: - DeleteTranscription
     * Delete transcription
     */
    deleteTranscriptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling deleteTranscription.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteTranscription.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling deleteTranscription.');
            }
            if (requestParameters.filename === null || requestParameters.filename === undefined) {
                throw new RequiredError('filename', 'Required parameter requestParameters.filename was null or undefined when calling deleteTranscription.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/{session}/transcriptions/{filename}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes transcription  Required permissions: - DeleteTranscription
     * Delete transcription
     */
    deleteTranscription(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteTranscriptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.ended  Required permissions: - EndCall
     * End call
     */
    endCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling endCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling endCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/mark_ended`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.ended  Required permissions: - EndCall
     * End call
     */
    endCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.endCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - ReadCall
     * Get Call
     */
    getCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCall.');
            }
            const queryParameters = {};
            if (requestParameters.membersLimit !== undefined) {
                queryParameters['members_limit'] = requestParameters.membersLimit;
            }
            if (requestParameters.ring !== undefined) {
                queryParameters['ring'] = requestParameters.ring;
            }
            if (requestParameters.notify !== undefined) {
                queryParameters['notify'] = requestParameters.notify;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - ReadCall
     * Get Call
     */
    getCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Get Call Stats
     */
    getCallStatsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCallStats.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCallStats.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling getCallStats.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stats/{session}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Get Call Stats
     */
    getCallStats(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallStatsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Get Call Type
     */
    getCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Get Call Type
     */
    getCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns the list of all edges available for video calls.
     * Get Edges
     */
    getEdgesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/edges`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Returns the list of all edges available for video calls.
     * Get Edges
     */
    getEdges(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getEdgesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings
     * Get or create a call
     */
    getOrCreateCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');
            }
            if (requestParameters.videoGetOrCreateCallRequest === null || requestParameters.videoGetOrCreateCallRequest === undefined) {
                throw new RequiredError('videoGetOrCreateCallRequest', 'Required parameter requestParameters.videoGetOrCreateCallRequest was null or undefined when calling getOrCreateCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoGetOrCreateCallRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings
     * Get or create a call
     */
    getOrCreateCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOrCreateCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall
     * Set call as live
     */
    goLiveRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling goLive.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling goLive.');
            }
            if (requestParameters.videoGoLiveRequest === null || requestParameters.videoGoLiveRequest === undefined) {
                throw new RequiredError('videoGoLiveRequest', 'Required parameter requestParameters.videoGoLiveRequest was null or undefined when calling goLive.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/go_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoGoLiveRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall
     * Set call as live
     */
    goLive(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.goLiveRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * List Call Type
     */
    listCallTypesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * List Call Type
     */
    listCallTypes(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listCallTypesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevicesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/devices`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevices(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listDevicesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists external storage
     * List external storage
     */
    listExternalStorageRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Lists external storage
     * List external storage
     */
    listExternalStorage(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listExternalStorageRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists recordings  Required permissions: - ListRecordings
     * List recordings
     */
    listRecordingsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listRecordings.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listRecordings.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/recordings`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Lists recordings  Required permissions: - ListRecordings
     * List recordings
     */
    listRecordings(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listRecordingsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists transcriptions  Required permissions: - ListTranscriptions
     * List transcriptions
     */
    listTranscriptionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/transcriptions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Lists transcriptions  Required permissions: - ListTranscriptions
     * List transcriptions
     */
    listTranscriptions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listTranscriptionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Mutes users in a call  Required permissions: - MuteUsers
     * Mute users
     */
    muteUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling muteUsers.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling muteUsers.');
            }
            if (requestParameters.videoMuteUsersRequest === null || requestParameters.videoMuteUsersRequest === undefined) {
                throw new RequiredError('videoMuteUsersRequest', 'Required parameter requestParameters.videoMuteUsersRequest was null or undefined when calling muteUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/mute_users`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoMuteUsersRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Mutes users in a call  Required permissions: - MuteUsers
     * Mute users
     */
    muteUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.muteUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Query call members with filter query  Required permissions: - ReadCall
     * Query call members
     */
    queryCallMembersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoQueryCallMembersRequest === null || requestParameters.videoQueryCallMembersRequest === undefined) {
                throw new RequiredError('videoQueryCallMembersRequest', 'Required parameter requestParameters.videoQueryCallMembersRequest was null or undefined when calling queryCallMembers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/members`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoQueryCallMembersRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Query call members with filter query  Required permissions: - ReadCall
     * Query call members
     */
    queryCallMembers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryCallMembersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Query Call Stats
     */
    queryCallStatsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoQueryCallStatsRequest === null || requestParameters.videoQueryCallStatsRequest === undefined) {
                throw new RequiredError('videoQueryCallStatsRequest', 'Required parameter requestParameters.videoQueryCallStatsRequest was null or undefined when calling queryCallStats.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/stats`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoQueryCallStatsRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Query Call Stats
     */
    queryCallStats(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryCallStatsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Query calls with filter query  Required permissions: - ReadCall
     * Query call
     */
    queryCallsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoQueryCallsRequest === null || requestParameters.videoQueryCallsRequest === undefined) {
                throw new RequiredError('videoQueryCallsRequest', 'Required parameter requestParameters.videoQueryCallsRequest was null or undefined when calling queryCalls.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calls`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoQueryCallsRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Query calls with filter query  Required permissions: - ReadCall
     * Query call
     */
    queryCalls(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryCallsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent
     * Send custom event
     */
    sendCallEventRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling sendCallEvent.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling sendCallEvent.');
            }
            if (requestParameters.videoSendCallEventRequest === null || requestParameters.videoSendCallEventRequest === undefined) {
                throw new RequiredError('videoSendCallEventRequest', 'Required parameter requestParameters.videoSendCallEventRequest was null or undefined when calling sendCallEvent.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoSendCallEventRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent
     * Send custom event
     */
    sendCallEvent(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCallEventRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting
     * Start HLS broadcasting
     */
    startHLSBroadcastingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/start_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting
     * Start HLS broadcasting
     */
    startHLSBroadcasting(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.startHLSBroadcastingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording
     * Start recording
     */
    startRecordingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startRecording.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startRecording.');
            }
            if (requestParameters.videoStartRecordingRequest === null || requestParameters.videoStartRecordingRequest === undefined) {
                throw new RequiredError('videoStartRecordingRequest', 'Required parameter requestParameters.videoStartRecordingRequest was null or undefined when calling startRecording.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/start_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoStartRecordingRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording
     * Start recording
     */
    startRecording(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.startRecordingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Starts transcription  Required permissions: - StartTranscription
     * Start transcription
     */
    startTranscriptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startTranscription.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startTranscription.');
            }
            if (requestParameters.videoStartTranscriptionRequest === null || requestParameters.videoStartTranscriptionRequest === undefined) {
                throw new RequiredError('videoStartTranscriptionRequest', 'Required parameter requestParameters.videoStartTranscriptionRequest was null or undefined when calling startTranscription.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/start_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoStartTranscriptionRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Starts transcription  Required permissions: - StartTranscription
     * Start transcription
     */
    startTranscription(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.startTranscriptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting
     * Stop HLS broadcasting
     */
    stopHLSBroadcastingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting
     * Stop HLS broadcasting
     */
    stopHLSBroadcasting(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopHLSBroadcastingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Set call as not live
     */
    stopLiveRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopLive.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopLive.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Set call as not live
     */
    stopLive(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopLiveRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording
     * Stop recording
     */
    stopRecordingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopRecording.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopRecording.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording
     * Stop recording
     */
    stopRecording(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopRecordingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription
     * Stop transcription
     */
    stopTranscriptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopTranscription.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopTranscription.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription
     * Stop transcription
     */
    stopTranscription(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopTranscriptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser
     * Unblocks user on a call
     */
    unblockUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling unblockUser.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling unblockUser.');
            }
            if (requestParameters.videoUnblockUserRequest === null || requestParameters.videoUnblockUserRequest === undefined) {
                throw new RequiredError('videoUnblockUserRequest', 'Required parameter requestParameters.videoUnblockUserRequest was null or undefined when calling unblockUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/unblock`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUnblockUserRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser
     * Unblocks user on a call
     */
    unblockUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unblockUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Update Call
     */
    updateCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCall.');
            }
            if (requestParameters.videoUpdateCallRequest === null || requestParameters.videoUpdateCallRequest === undefined) {
                throw new RequiredError('videoUpdateCallRequest', 'Required parameter requestParameters.videoUpdateCallRequest was null or undefined when calling updateCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateCallRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Update Call
     */
    updateCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole
     * Update Call Member
     */
    updateCallMembersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');
            }
            if (requestParameters.videoUpdateCallMembersRequest === null || requestParameters.videoUpdateCallMembersRequest === undefined) {
                throw new RequiredError('videoUpdateCallMembersRequest', 'Required parameter requestParameters.videoUpdateCallMembersRequest was null or undefined when calling updateCallMembers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/members`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateCallMembersRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole
     * Update Call Member
     */
    updateCallMembers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCallMembersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Update Call Type
     */
    updateCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateCallType.');
            }
            if (requestParameters.videoUpdateCallTypeRequest === null || requestParameters.videoUpdateCallTypeRequest === undefined) {
                throw new RequiredError('videoUpdateCallTypeRequest', 'Required parameter requestParameters.videoUpdateCallTypeRequest was null or undefined when calling updateCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateCallTypeRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Update Call Type
     */
    updateCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Update External Storage
     */
    updateExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');
            }
            if (requestParameters.videoUpdateExternalStorageRequest === null || requestParameters.videoUpdateExternalStorageRequest === undefined) {
                throw new RequiredError('videoUpdateExternalStorageRequest', 'Required parameter requestParameters.videoUpdateExternalStorageRequest was null or undefined when calling updateExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateExternalStorageRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Update External Storage
     */
    updateExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions
     * Update user permissions
     */
    updateUserPermissionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');
            }
            if (requestParameters.videoUpdateUserPermissionsRequest === null || requestParameters.videoUpdateUserPermissionsRequest === undefined) {
                throw new RequiredError('videoUpdateUserPermissionsRequest', 'Required parameter requestParameters.videoUpdateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/user_permissions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateUserPermissionsRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions
     * Update user permissions
     */
    updateUserPermissions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateUserPermissionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack
     * Pin
     */
    videoPinRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoPin.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoPin.');
            }
            if (requestParameters.videoPinRequest === null || requestParameters.videoPinRequest === undefined) {
                throw new RequiredError('videoPinRequest', 'Required parameter requestParameters.videoPinRequest was null or undefined when calling videoPin.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/pin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoPinRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack
     * Pin
     */
    videoPin(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.videoPinRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack
     * Unpin
     */
    videoUnpinRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoUnpin.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoUnpin.');
            }
            if (requestParameters.videoUnpinRequest === null || requestParameters.videoUnpinRequest === undefined) {
                throw new RequiredError('videoUnpinRequest', 'Required parameter requestParameters.videoUnpinRequest was null or undefined when calling videoUnpin.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/unpin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUnpinRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack
     * Unpin
     */
    videoUnpin(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.videoUnpinRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

class StreamCall {
    constructor(streamClient, type, id) {
        this.streamClient = streamClient;
        this.type = type;
        this.id = id;
        this.blockUser = (videoBlockUserRequest) => {
            return this.apiClient.blockUser(Object.assign(Object.assign({}, this.baseRequest), { videoBlockUserRequest }));
        };
        this.endCall = () => {
            return this.apiClient.endCall(Object.assign({}, this.baseRequest));
        };
        this.get = (request) => {
            return this.apiClient.getCall(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest));
        };
        this.getOrCreate = (videoGetOrCreateCallRequest) => {
            return this.apiClient.getOrCreateCall(Object.assign(Object.assign({}, this.baseRequest), { videoGetOrCreateCallRequest: videoGetOrCreateCallRequest !== null && videoGetOrCreateCallRequest !== void 0 ? videoGetOrCreateCallRequest : {} }));
        };
        this.getSessionStatistics = (request) => {
            return this.apiClient.getCallStats(Object.assign(Object.assign({}, this.baseRequest), request));
        };
        this.create = (getOrCreateCallRequest) => {
            return this.getOrCreate(getOrCreateCallRequest);
        };
        this.goLive = (videoGoLiveRequest) => {
            return this.apiClient.goLive(Object.assign(Object.assign({}, this.baseRequest), { videoGoLiveRequest: videoGoLiveRequest !== null && videoGoLiveRequest !== void 0 ? videoGoLiveRequest : {} }));
        };
        this.listRecordings = () => {
            return this.apiClient.listRecordings(Object.assign({}, this.baseRequest));
        };
        this.deleteRecording = (request) => {
            return this.apiClient.deleteRecording(Object.assign(Object.assign({}, this.baseRequest), request));
        };
        this.listTranscriptions = () => {
            return this.apiClient.listTranscriptions(Object.assign({}, this.baseRequest));
        };
        this.muteUsers = (videoMuteUsersRequest) => {
            return this.apiClient.muteUsers(Object.assign(Object.assign({}, this.baseRequest), { videoMuteUsersRequest }));
        };
        this.queryMembers = (request) => {
            return this.apiClient.queryCallMembers({
                videoQueryCallMembersRequest: Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest),
            });
        };
        this.sendCustomEvent = (videoSendCallEventRequest) => {
            return this.apiClient.sendCallEvent(Object.assign({ videoSendCallEventRequest }, this.baseRequest));
        };
        this.startHLSBroadcasting = () => {
            return this.apiClient.startHLSBroadcasting(Object.assign({}, this.baseRequest));
        };
        this.startRecording = (request) => {
            return this.apiClient.startRecording(Object.assign(Object.assign({}, this.baseRequest), { videoStartRecordingRequest: request !== null && request !== void 0 ? request : {} }));
        };
        this.startTranscription = (videoStartTranscriptionRequest = {}) => {
            return this.apiClient.startTranscription(Object.assign(Object.assign({}, this.baseRequest), { videoStartTranscriptionRequest }));
        };
        this.deleteTranscription = (request) => {
            return this.apiClient.deleteTranscription(Object.assign(Object.assign({}, this.baseRequest), request));
        };
        this.stopHLSBroadcasting = () => {
            return this.apiClient.stopHLSBroadcasting(Object.assign({}, this.baseRequest));
        };
        this.stopLive = () => {
            return this.apiClient.stopLive(Object.assign({}, this.baseRequest));
        };
        this.stopRecording = () => {
            return this.apiClient.stopRecording(Object.assign({}, this.baseRequest));
        };
        this.stopTranscription = () => {
            return this.apiClient.stopTranscription(Object.assign({}, this.baseRequest));
        };
        this.unblockUser = (videoUnblockUserRequest) => {
            return this.apiClient.unblockUser(Object.assign({ videoUnblockUserRequest }, this.baseRequest));
        };
        this.update = (videoUpdateCallRequest) => {
            return this.apiClient.updateCall(Object.assign({ videoUpdateCallRequest }, this.baseRequest));
        };
        this.updateCallMembers = (videoUpdateCallMembersRequest) => {
            return this.apiClient.updateCallMembers(Object.assign({ videoUpdateCallMembersRequest }, this.baseRequest));
        };
        this.updateUserPermissions = (videoUpdateUserPermissionsRequest) => {
            return this.apiClient.updateUserPermissions(Object.assign({ videoUpdateUserPermissionsRequest }, this.baseRequest));
        };
        this.pinVideo = (videoPinRequest) => {
            return this.apiClient.videoPin(Object.assign({ videoPinRequest }, this.baseRequest));
        };
        this.unpinVideo = (videoUnpinRequest) => {
            return this.apiClient.videoUnpin(Object.assign({ videoUnpinRequest }, this.baseRequest));
        };
        this.baseRequest = { id: this.id, type: this.type };
        const configuration = this.streamClient.getConfiguration('video');
        this.apiClient = new ProductvideoApi(configuration);
    }
}

class StreamVideoClient {
    constructor(streamClient) {
        this.streamClient = streamClient;
        this.call = (type, id) => {
            return new StreamCall(this.streamClient, type, id);
        };
        this.queryCalls = (request) => {
            return this.apiClient.queryCalls({
                videoQueryCallsRequest: request !== null && request !== void 0 ? request : {},
            });
        };
        this.queryCallStatistics = (videoQueryCallStatsRequest) => {
            return this.apiClient.queryCallStats({
                videoQueryCallStatsRequest: videoQueryCallStatsRequest !== null && videoQueryCallStatsRequest !== void 0 ? videoQueryCallStatsRequest : {},
            });
        };
        this.createCallType = (videoCreateCallTypeRequest) => {
            return this.apiClient.createCallType({
                videoCreateCallTypeRequest,
            });
        };
        this.deleteCallType = (request) => {
            return this.apiClient.deleteCallType(request);
        };
        this.getCallType = (request) => {
            return this.apiClient.getCallType(request);
        };
        this.listCallTypes = () => {
            return this.apiClient.listCallTypes();
        };
        this.updateCallType = (name, videoUpdateCallTypeRequest) => {
            return this.apiClient.updateCallType({
                name,
                videoUpdateCallTypeRequest,
            });
        };
        this.listExternalStorages = () => {
            return this.apiClient.listExternalStorage();
        };
        this.createExternalStorage = (videoCreateExternalStorageRequest) => {
            return this.apiClient.createExternalStorage({
                videoCreateExternalStorageRequest,
            });
        };
        this.deleteExternalStorage = (request) => {
            return this.apiClient.deleteExternalStorage(request);
        };
        this.updateExternalStorage = (name, videoUpdateExternalStorageRequest) => {
            return this.apiClient.updateExternalStorage({
                name,
                videoUpdateExternalStorageRequest,
            });
        };
        this.checkExternalStorage = (request) => {
            return this.apiClient.checkExternalStorage(request);
        };
        const configuration = this.streamClient.getConfiguration('video');
        this.apiClient = new ProductvideoApi(configuration);
    }
}

function JWTUserToken(apiSecret, payload) {
    // make sure we return a clear error when jwt is shimmed (ie. browser build)
    if (jwt == null || jwt.sign == null) {
        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);
    }
    const opts = Object.assign({
        algorithm: 'HS256',
        noTimestamp: true,
    });
    if (payload.iat) {
        opts.noTimestamp = false;
    }
    return jwt.sign(payload, apiSecret, opts);
}
function JWTServerToken(apiSecret, jwtOptions = {}) {
    const payload = {
        server: true,
    };
    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);
    return jwt.sign(payload, apiSecret, opts);
}

class StreamClient {
    /**
     *
     * @param apiKey
     * @param secret
     * @param config can be a string, which will be interpreted as base path (deprecated), or a config object
     */
    constructor(apiKey, secret, config) {
        var _a;
        this.apiKey = apiKey;
        this.secret = secret;
        this.config = config;
        this.options = {};
        this.createDevice = (createDeviceRequest) => {
            return this.devicesApi.createDevice({ createDeviceRequest });
        };
        this.deleteDevice = (requestParameters) => {
            return this.devicesApi.deleteDevice(requestParameters);
        };
        this.listDevices = (requestParameters) => {
            return this.devicesApi.listDevices(requestParameters);
        };
        this.listPushProviders = () => {
            return this.pushApi.listPushProviders();
        };
        this.deletePushProvider = (request) => {
            return this.pushApi.deletePushProvider(request);
        };
        this.upsertPushProvider = (request) => {
            return this.serversideApi.upsertPushProvider({
                upsertPushProviderRequest: { push_provider: request },
            });
        };
        this.checkPush = (checkPushRequest) => {
            return this.testingApi.checkPush({ checkPushRequest });
        };
        this.createGuest = (guestRequest) => __awaiter(this, void 0, void 0, function* () {
            guestRequest.user = this.mapCustomDataBeforeSend(guestRequest.user);
            const response = yield this.usersApi.createGuest({ guestRequest });
            response.user = this.mapCustomDataAfterReceive(response.user);
            return response;
        });
        this.banUser = (banRequest) => {
            banRequest.user = this.mapCustomDataBeforeSend(banRequest.user);
            banRequest.banned_by = this.mapCustomDataBeforeSend(banRequest.banned_by);
            return this.usersApi.ban({ banRequest });
        };
        this.deactivateUser = (deactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.usersApi.deactivateUser({
                deactivateUserRequest,
                userId: deactivateUserRequest.user_id,
            });
            response.user = this.mapCustomDataAfterReceive(response.user);
            return response;
        });
        this.deactivateUsers = (deactivateUsersRequest) => {
            return this.usersApi.deactivateUsers({ deactivateUsersRequest });
        };
        /**
         * @deprecated use `deleteUsers` instead
         * @param deleteUsersRequest
         * @returns
         */
        this.deleteUser = (request) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.usersApi.deleteUser(request);
            response.user = this.mapCustomDataAfterReceive(response.user);
            return response;
        });
        this.deleteUsers = (deleteUsersRequest) => {
            return this.usersApi.deleteUsers({ deleteUsersRequest });
        };
        this.exportUser = (request) => {
            return this.usersApi.exportUser(request);
        };
        this.exportUsers = (exportUsersRequest) => {
            return this.usersApi.exportUsers({ exportUsersRequest });
        };
        this.flag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {
            var _b, _c;
            flagRequest.user = this.mapCustomDataBeforeSend(flagRequest.user);
            const response = yield this.usersApi.flag({ flagRequest });
            if ((_b = response.flag) === null || _b === void 0 ? void 0 : _b.user) {
                response.flag.user = this.mapCustomDataAfterReceive((_c = response.flag) === null || _c === void 0 ? void 0 : _c.user);
            }
            return response;
        });
        this.queryBannedUsers = (payload) => __awaiter(this, void 0, void 0, function* () {
            payload.user = this.mapCustomDataBeforeSend(payload.user);
            const response = yield this.usersApi.queryBannedUsers({ payload });
            response.bans.forEach((b) => {
                b.banned_by = this.mapCustomDataAfterReceive(b.banned_by);
                b.user = this.mapCustomDataAfterReceive(b.user);
            });
            return response;
        });
        this.queryUsers = (payload) => __awaiter(this, void 0, void 0, function* () {
            payload.user = this.mapCustomDataBeforeSend(payload.user);
            const response = yield this.usersApi.queryUsers({ payload });
            /** @ts-expect-error */
            response.users = response.users.map((u) => this.mapCustomDataAfterReceive(u));
            return response;
        });
        this.reactivateUser = (reactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.usersApi.reactivateUser({
                reactivateUserRequest,
                userId: reactivateUserRequest.user_id,
            });
            response.user = this.mapCustomDataAfterReceive(response.user);
        });
        this.reactivateUsers = (reactivateUsersRequest) => {
            return this.usersApi.reactivateUsers({ reactivateUsersRequest });
        };
        this.restoreUsers = (restoreUsersRequest) => {
            return this.usersApi.restoreUsers({ restoreUsersRequest });
        };
        this.unbanUser = (request) => {
            return this.usersApi.unban(request);
        };
        this.unflag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {
            var _d;
            const response = yield this.usersApi.unflag({ flagRequest });
            if ((_d = response.flag) === null || _d === void 0 ? void 0 : _d.user) {
                response.flag.user = this.mapCustomDataAfterReceive(response.flag.user);
            }
            return response;
        });
        this.upsertUsers = (updateUsersRequest) => __awaiter(this, void 0, void 0, function* () {
            Object.keys(updateUsersRequest.users).forEach((key) => {
                updateUsersRequest.users[key] = this.mapCustomDataBeforeSend(updateUsersRequest.users[key]);
            });
            const response = yield this.usersApi.updateUsers({ updateUsersRequest });
            Object.keys(response.users).forEach((key) => {
                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);
            });
            return response;
        });
        this.updateUsersPartial = (request) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this.usersApi.updateUsersPartial({
                /** @ts-expect-error */
                updateUserPartialRequest: request,
            });
            Object.keys(response.users).forEach((key) => {
                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);
            });
            return response;
        });
        this.muteUser = (muteUserRequest) => __awaiter(this, void 0, void 0, function* () {
            var _e, _f;
            muteUserRequest.user = this.mapCustomDataBeforeSend(muteUserRequest.user);
            const response = yield this.usersApi.muteUser({ muteUserRequest });
            if ((_e = response.mute) === null || _e === void 0 ? void 0 : _e.user) {
                response.mute.user = this.mapCustomDataAfterReceive((_f = response.mute) === null || _f === void 0 ? void 0 : _f.user);
            }
            if (response.mutes) {
                response.mutes = response.mutes.map((m) => {
                    return Object.assign(Object.assign({}, m), { user: this.mapCustomDataAfterReceive(m.user) });
                });
            }
            return response;
        });
        this.unmuteUser = (unmuteUserRequest) => {
            unmuteUserRequest.user = this.mapCustomDataBeforeSend(unmuteUserRequest.user);
            return this.usersApi.unmuteUser({ unmuteUserRequest });
        };
        this.sendCustomEventToUser = (userId, event) => {
            return this.eventsApi.sendUserCustomEvent({
                userId,
                sendUserCustomEventRequest: { event },
            });
        };
        this.createRole = (createRoleRequest) => {
            return this.permissionsApi.createRole({ createRoleRequest });
        };
        this.deleteRole = (request) => {
            return this.permissionsApi.deleteRole(request);
        };
        this.getPermission = (request) => {
            return this.permissionsApi.getPermission(request);
        };
        this.listPermissions = () => {
            return this.permissionsApi.listPermissions();
        };
        this.listRoles = () => {
            return this.permissionsApi.listRoles();
        };
        this.getAppSettings = () => {
            return this.settingsApi.getApp();
        };
        this.updateAppSettings = (updateAppRequest) => {
            return this.settingsApi.updateApp({ updateAppRequest });
        };
        this.getRateLimits = () => {
            return this.settingsApi.getRateLimits();
        };
        this.getTaskStatus = (request) => {
            return this.tasksApi.getTask(request);
        };
        this.verifyWebhook = (requestBody, xSignature) => {
            const key = Buffer.from(this.secret, 'utf8');
            const hash = crypto
                .createHmac('sha256', key)
                .update(requestBody)
                .digest('hex');
            try {
                return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));
            }
            catch (err) {
                return false;
            }
        };
        this.getConfiguration = (product = 'chat') => {
            var _a;
            return new Configuration({
                apiKey: (name) => {
                    const mapping = {
                        'Stream-Auth-Type': 'jwt',
                        api_key: this.apiKey,
                        Authorization: this.token,
                    };
                    return mapping[name];
                },
                basePath: (_a = this.options.basePath) !== null && _a !== void 0 ? _a : (product === 'chat'
                    ? 'https://chat.stream-io-api.com'
                    : 'https://video.stream-io-api.com'),
                headers: {
                    'X-Stream-Client': 'stream-node-' + "0.2.5",
                },
                middleware: [
                    {
                        pre: (context) => {
                            context.init.headers = Object.assign(Object.assign({}, context.init.headers), { 'x-client-request-id': uuid.v4(), 'Accept-Encoding': 'gzip' });
                            return Promise.resolve(context);
                        },
                    },
                    {
                        // This should be the last post middleware because that will throw an error
                        // The Fetch API won't throw an error for HTTP error responses, which means the "onError" middleware won't be called so we need to throw error from "post" middleware
                        post: (context) => __awaiter(this, void 0, void 0, function* () {
                            if ((context.response && context.response.status < 200) ||
                                context.response.status >= 300) {
                                const response = new JSONApiResponse(context.response);
                                const value = (yield response.value());
                                throw new Error(`Stream error code ${value.code}: ${value.message}`);
                            }
                        }),
                    },
                    {
                        pre: (context) => {
                            context.init.signal = AbortSignal.timeout(this.options.timeout);
                            return Promise.resolve(context);
                        },
                        onError: (context) => {
                            const error = context.error;
                            if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                                throw new FetchError(error, `The request was aborted due to to the ${this.options.timeout}ms timeout, you can set the timeout in the StreamClient constructor`);
                            }
                            return Promise.resolve(context.response);
                        },
                    },
                ],
                // https://github.com/OpenAPITools/openapi-generator/issues/13222
                queryParamsStringify: (params) => {
                    const newParams = [];
                    for (const k in params) {
                        const param = params[k];
                        if (Array.isArray(param)) {
                            newParams.push(`${k}=${encodeURIComponent(param.join(','))}`);
                        }
                        else if (typeof param === 'object') {
                            newParams.push(`${k}=${encodeURIComponent(JSON.stringify(param))}`);
                        }
                        else {
                            if (typeof param === 'string' ||
                                typeof param === 'number' ||
                                typeof param === 'boolean') {
                                newParams.push(`${k}=${encodeURIComponent(param)}`);
                            }
                        }
                    }
                    return newParams.join('&');
                },
            });
        };
        this.reservedKeywords = [
            'ban_expires',
            'banned',
            'id',
            'invisible',
            'language',
            'push_notifications',
            'revoke_tokens_issued_before',
            'role',
            'teams',
            'created_at',
            'deactivated_at',
            'deleted_at',
            'last_active',
            'online',
            'updated_at',
            'shadow_banned',
            'name',
            'image',
        ];
        this.mapCustomDataBeforeSend = (user) => {
            if (!user) {
                return undefined;
            }
            const copy = Object.assign({}, user);
            delete copy.custom;
            return Object.assign(Object.assign({}, copy), user.custom);
        };
        this.token = JWTServerToken(this.secret);
        if (typeof config === 'string') {
            this.options.basePath = config;
            this.options.timeout = StreamClient.DEFAULT_TIMEOUT;
        }
        else {
            if (config) {
                this.options = config;
            }
            this.options.timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : StreamClient.DEFAULT_TIMEOUT;
        }
        this.video = new StreamVideoClient(this);
        this.chat = new StreamChatClient(this);
        const chatConfiguration = this.getConfiguration();
        /** @ts-expect-error */
        this.usersApi = new UsersApi(chatConfiguration);
        /** @ts-expect-error */
        this.devicesApi = new DevicesApi(chatConfiguration);
        /** @ts-expect-error */
        this.pushApi = new PushApi(chatConfiguration);
        /** @ts-expect-error */
        this.serversideApi = new ServerSideApi(chatConfiguration);
        /** @ts-expect-error */
        this.testingApi = new TestingApi(chatConfiguration);
        /** @ts-expect-error */
        this.permissionsApi = new PermissionsV2Api(chatConfiguration);
        /** @ts-expect-error */
        this.settingsApi = new SettingsApi(chatConfiguration);
        /** @ts-expect-error */
        this.eventsApi = new EventsApi(chatConfiguration);
        /** @ts-expect-error */
        this.tasksApi = new TasksApi(chatConfiguration);
    }
    /**
     *
     * @param userID
     * @param exp
     * @param iat deprecated, the default date will be set internally
     * @param call_cids this parameter is deprecated use `createCallToken` for call tokens
     * @returns
     */
    createToken(userID, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000), call_cids) {
        const payload = {
            user_id: userID,
            exp,
            iat,
        };
        if (call_cids) {
            console.warn(`Use createCallToken method for creating call tokens, the "call_cids" param will be removed from the createToken method with version 0.2.0`);
            payload.call_cids = call_cids;
        }
        return JWTUserToken(this.secret, payload);
    }
    /**
     *
     * @param userID
     * @param call_cids
     * @param exp
     * @param iat this is deprecated, the current date will be set internally
     * @returns
     */
    createCallToken(userIdOrObject, call_cids, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000)) {
        const payload = {
            exp,
            iat,
            call_cids,
            user_id: typeof userIdOrObject === 'string'
                ? userIdOrObject
                : userIdOrObject.user_id,
        };
        if (typeof userIdOrObject === 'object' && userIdOrObject.role) {
            payload.role = userIdOrObject.role;
        }
        return JWTUserToken(this.secret, payload);
    }
    mapCustomDataAfterReceive(user) {
        if (!user) {
            return undefined;
        }
        /** @ts-expect-error */
        const result = {};
        Object.keys(user).forEach((key) => {
            if (!this.reservedKeywords.includes(key)) {
                if (!result.custom) {
                    result.custom = {};
                }
                result.custom[key] = user[key];
            }
            else {
                result[key] = user[key];
            }
        });
        return result;
    }
}
StreamClient.DEFAULT_TIMEOUT = 3000;

exports.APNConfigRequestAuthTypeEnum = APNConfigRequestAuthTypeEnum;
exports.AppSearchBackendEnum = AppSearchBackendEnum;
exports.AsyncModerationCallbackConfigRequestModeEnum = AsyncModerationCallbackConfigRequestModeEnum;
exports.AudioSettingsDefaultDeviceEnum = AudioSettingsDefaultDeviceEnum;
exports.BlockListOptionsBehaviorEnum = BlockListOptionsBehaviorEnum;
exports.BlockListOptionsRequestBehaviorEnum = BlockListOptionsRequestBehaviorEnum;
exports.ChannelConfigAutomodBehaviorEnum = ChannelConfigAutomodBehaviorEnum;
exports.ChannelConfigAutomodEnum = ChannelConfigAutomodEnum;
exports.ChannelConfigBlocklistBehaviorEnum = ChannelConfigBlocklistBehaviorEnum;
exports.ChannelConfigRequestBlocklistBehaviorEnum = ChannelConfigRequestBlocklistBehaviorEnum;
exports.ChannelConfigWithInfoAutomodBehaviorEnum = ChannelConfigWithInfoAutomodBehaviorEnum;
exports.ChannelConfigWithInfoAutomodEnum = ChannelConfigWithInfoAutomodEnum;
exports.ChannelConfigWithInfoBlocklistBehaviorEnum = ChannelConfigWithInfoBlocklistBehaviorEnum;
exports.ChannelConfigWithInfoRequestAutomodBehaviorEnum = ChannelConfigWithInfoRequestAutomodBehaviorEnum;
exports.ChannelConfigWithInfoRequestAutomodEnum = ChannelConfigWithInfoRequestAutomodEnum;
exports.ChannelConfigWithInfoRequestBlocklistBehaviorEnum = ChannelConfigWithInfoRequestBlocklistBehaviorEnum;
exports.ChannelMemberRequestRoleEnum = ChannelMemberRequestRoleEnum;
exports.ChannelMemberRoleEnum = ChannelMemberRoleEnum;
exports.ChannelTypeConfigAutomodBehaviorEnum = ChannelTypeConfigAutomodBehaviorEnum;
exports.ChannelTypeConfigAutomodEnum = ChannelTypeConfigAutomodEnum;
exports.ChannelTypeConfigBlocklistBehaviorEnum = ChannelTypeConfigBlocklistBehaviorEnum;
exports.CheckPushRequestPushProviderTypeEnum = CheckPushRequestPushProviderTypeEnum;
exports.CheckSNSResponseStatusEnum = CheckSNSResponseStatusEnum;
exports.CheckSQSResponseStatusEnum = CheckSQSResponseStatusEnum;
exports.ConfigDefaultRoleEnum = ConfigDefaultRoleEnum;
exports.ConfigRequestDefaultRoleEnum = ConfigRequestDefaultRoleEnum;
exports.CreateCallRequestTypeEnum = CreateCallRequestTypeEnum;
exports.CreateChannelTypeRequestAutomodBehaviorEnum = CreateChannelTypeRequestAutomodBehaviorEnum;
exports.CreateChannelTypeRequestAutomodEnum = CreateChannelTypeRequestAutomodEnum;
exports.CreateChannelTypeRequestBlocklistBehaviorEnum = CreateChannelTypeRequestBlocklistBehaviorEnum;
exports.CreateChannelTypeResponseAutomodBehaviorEnum = CreateChannelTypeResponseAutomodBehaviorEnum;
exports.CreateChannelTypeResponseAutomodEnum = CreateChannelTypeResponseAutomodEnum;
exports.CreateChannelTypeResponseBlocklistBehaviorEnum = CreateChannelTypeResponseBlocklistBehaviorEnum;
exports.CreateDeviceRequestPushProviderEnum = CreateDeviceRequestPushProviderEnum;
exports.CreateImportRequestModeEnum = CreateImportRequestModeEnum;
exports.DeleteUsersRequestConversationsEnum = DeleteUsersRequestConversationsEnum;
exports.DeleteUsersRequestMessagesEnum = DeleteUsersRequestMessagesEnum;
exports.DeleteUsersRequestUserEnum = DeleteUsersRequestUserEnum;
exports.DeviceFieldsPushProviderEnum = DeviceFieldsPushProviderEnum;
exports.DevicePushProviderEnum = DevicePushProviderEnum;
exports.DeviceRequestPushProviderEnum = DeviceRequestPushProviderEnum;
exports.ImageSizeCropEnum = ImageSizeCropEnum;
exports.ImageSizeResizeEnum = ImageSizeResizeEnum;
exports.LayoutSettingsNameEnum = LayoutSettingsNameEnum;
exports.MessageRequest1TypeEnum = MessageRequest1TypeEnum;
exports.MessageRequestTypeEnum = MessageRequestTypeEnum;
exports.MessageTypeEnum = MessageTypeEnum;
exports.PermissionLevelEnum = PermissionLevelEnum;
exports.PolicyRequest1ActionEnum = PolicyRequest1ActionEnum;
exports.PolicyRequestActionEnum = PolicyRequestActionEnum;
exports.PushConfigRequestVersionEnum = PushConfigRequestVersionEnum;
exports.StreamCall = StreamCall;
exports.StreamChannel = StreamChannel;
exports.StreamChatClient = StreamChatClient;
exports.StreamClient = StreamClient;
exports.StreamVideoClient = StreamVideoClient;
exports.TranscriptionSettingsModeEnum = TranscriptionSettingsModeEnum;
exports.TranslateMessageRequestLanguageEnum = TranslateMessageRequestLanguageEnum;
exports.UpdateAppRequestEnforceUniqueUsernamesEnum = UpdateAppRequestEnforceUniqueUsernamesEnum;
exports.UpdateAppRequestPermissionVersionEnum = UpdateAppRequestPermissionVersionEnum;
exports.UpdateAppRequestVideoProviderEnum = UpdateAppRequestVideoProviderEnum;
exports.UpdateChannelTypeRequestAutomodBehaviorEnum = UpdateChannelTypeRequestAutomodBehaviorEnum;
exports.UpdateChannelTypeRequestAutomodEnum = UpdateChannelTypeRequestAutomodEnum;
exports.UpdateChannelTypeRequestBlocklistBehaviorEnum = UpdateChannelTypeRequestBlocklistBehaviorEnum;
exports.UpdateChannelTypeResponseAutomodBehaviorEnum = UpdateChannelTypeResponseAutomodBehaviorEnum;
exports.UpdateChannelTypeResponseAutomodEnum = UpdateChannelTypeResponseAutomodEnum;
exports.UpdateChannelTypeResponseBlocklistBehaviorEnum = UpdateChannelTypeResponseBlocklistBehaviorEnum;
exports.VideoAudioSettingsRequestDefaultDeviceEnum = VideoAudioSettingsRequestDefaultDeviceEnum;
exports.VideoAudioSettingsResponseDefaultDeviceEnum = VideoAudioSettingsResponseDefaultDeviceEnum;
exports.VideoCreateDeviceRequestPushProviderEnum = VideoCreateDeviceRequestPushProviderEnum;
exports.VideoDevicePushProviderEnum = VideoDevicePushProviderEnum;
exports.VideoLayoutSettingsRequestNameEnum = VideoLayoutSettingsRequestNameEnum;
exports.VideoLayoutSettingsResponseNameEnum = VideoLayoutSettingsResponseNameEnum;
exports.VideoNoiseCancellationSettingsModeEnum = VideoNoiseCancellationSettingsModeEnum;
exports.VideoOwnCapability = VideoOwnCapability;
exports.VideoRecordSettingsRequestModeEnum = VideoRecordSettingsRequestModeEnum;
exports.VideoRecordSettingsRequestQualityEnum = VideoRecordSettingsRequestQualityEnum;
exports.VideoSettingsCameraFacingEnum = VideoSettingsCameraFacingEnum;
exports.VideoTranscriptionSettingsRequestModeEnum = VideoTranscriptionSettingsRequestModeEnum;
exports.VideoTranscriptionSettingsResponseModeEnum = VideoTranscriptionSettingsResponseModeEnum;
exports.VideoVideoSettingsRequestCameraFacingEnum = VideoVideoSettingsRequestCameraFacingEnum;
exports.VideoVideoSettingsResponseCameraFacingEnum = VideoVideoSettingsResponseCameraFacingEnum;
//# sourceMappingURL=index.cjs.js.map
